#pragma config(Sensor, S1,     lightSensor,    sensorLightActive)
#pragma config(Sensor, S2,     sonarSensor,    sensorSONAR)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/* 
-----------------------------------
Team Computing Project CA
Luke Griffin and Connor Heaphy
Started: 04/03/2015
Finished:
-----------------------------------
*/


//prototypes
void move_foward(int line_count);
void sense_object(int line_count, int sense);


task main()
{
	int line_count = 0;
	int sense;
	
	sense_object(line_count,sense);
	
}//End main()

void move_foward (int line_count)
{
	while (SensorValue(lightSensor) > 25)
	{
		
		motor[motorB] = 50;
		motor[motorC] = 50;
		
		nxtDisplayBigStringAt(25, 25, "%d", line_count);
	  nxtDisplayCenteredTextLine(1, "The Line Count");
	  nxtDisplayCenteredTextLine(2, "is");
	  
		if (SensorValue(lightSensor) < 45)
		{
			wait1Msec(50);
			
			line_count = line_count + 1;
			
			if (SensorValue(lightSensor) < 45)//stop at black cell
			{
				motor[motorB] = 0;
				motor[motorC] = 0;
				
				line_count = line_count - 1;	
				
			}//End if()
			
		}//End if()
		
	}//End while()
	
}//End function move_foward

void sense_object (int line_count, int sense)
{
	
	motor[motorB] = 50;
	motor[motorC] = 50;
	
	line_count = line_count + 1;
	
	nMotorEncoder[motorB] = 0;
	nMotorEncoder[motorC] = 0;
	
	while(nMotorEncoder[motorC] < 360)//turn left
	{
		motor[motorC] = 50;
		motor[motorB] = 0;
	}//End while()
			
	wait1Msec(50);
			
	if(SensorValue(sonarSensor) < 45)//if object is found move to
	{
		motor[motorB] = 50;
		motor[motorC] = 50;
		
		if(SensorValue(sonarSensor) > 5)//object found stop
		{
			motor[motorB] = 0;
			motor[motorC] = 0;
		}

	}
			
	
			
}//End Function sense_object()





/*-------------------------------------------------------------
Function for returning to starting block
---------------------------------------------------------------

/* Returning to starting cell
*/

task main()
{
	//test, valid if travelled 50 cm across, and 20 cm up
	//robot must be facing towards the direction of the starting
	//block, but not directly at the block itself.
	
	nMotorEncoder[motorB] = 0;
	nMotorEncoder[motorC] = 0;
	while(nMotorEncoder[motorB] < angle_of_start)
	{
		motor[motorB] = 40;
		motor[motorC] = 0;
	}//End while
	
	
	//Robot now faces the block. Must now travel in a 
	//straight line to get to starting cell.
	nMotorEncoder[motorB] = 0;
	nMotorEncoder[motorC] = 0;
	while(nMotorEncoder[motorB] < hypotenuse)
	{
		motor[motorB] = 40;
		motor[motorC] = 40;
	}//End while

}//End main()	

*/
